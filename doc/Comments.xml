<Chapter Label="Comments">
<Heading>&AutoDoc; documentation comments</Heading>

You can document declarations of global functions and variables, operations,
attributes etc. by inserting &AutoDoc; comments into your sources before these declaration.
An &AutoDoc; comment always starts with <C>#!</C>. This is also the smallest possible
&AutoDoc; command. If you want your declaration documented, just write
<C>#!</C> at the line before the documentation. For example:

<Listing><![CDATA[
#!
DeclareOperation( "AnOperation",
                  [ IsList ] );
]]></Listing>

This will produce a manual entry for the operation <C>AnOperation</C>.


<Section>
<Heading>Documenting declarations</Heading>

In the bare form above, the manual entry for <C>AnOperation</C> will not
contain much more than the name of the operation. In order to change
this, there are several commands you can put into the &AutoDoc; comment
before the declaration. Currently, the following commands are provided:

<Subsection Label="@Description">
<Index Key="@Description"><C>@Description</C></Index>
<Heading>@Description <A>descr</A></Heading>
Adds the text in the following lines of the &AutoDoc; to the description
of the declaration in the manual. Lines are until the next &AutoDoc; command
or until the declaration is reached.
</Subsection>

<Subsection Label="@Returns">
<Index Key="@Returns"><C>@Returns</C></Index>
<Heading>@Returns <A>ret_val</A></Heading>
The string <A>ret_val</A> is added to the documentation, with the text <Q>Returns: </Q>
put in front of it. This should usually give a brief hint about the type or meaning
of the value retuned by the documented function.
</Subsection>

<Subsection Label="@Arguments">
<Index Key="@Arguments"><C>@Arguments</C></Index>
<Heading>@Arguments <A>args</A></Heading>
The string <A>args</A> contains a description of the arguments the
function expects, including optional parts, which are denoted by square
brackets. The argument names can be separated by whitespace, commas or
square brackets for the optional arguments, like <Q>grp[, elm]</Q> or
<Q>xx[y[z] ]</Q>. If &GAP; options are used, this can be followed by a colon :
and one or more assignments, like <Q>n[, r]: tries := 100</Q>.
</Subsection>

<Subsection Label="@Group">
<Index Key="@Group"><C>@Group</C></Index>
<Heading>@Group <A>grpname</A></Heading>
Adds the following method to a group with the given name.
See section <Ref Sect="Groups"/> for more information about groups.
</Subsection>

<Subsection Label="@FunctionLabel">
<Index Key="@FunctionLabel"><C>@FunctionLabel</C></Index>
<Heading>@FunctionLabel <A>label</A></Heading>
Adds label to the function as label.

If this is not specified, then for declarations that involve a list of input filters
(as is the case for <C>DeclareOperation</C>, <C>DeclareAttribute</C>, etc.),
a default label is generated from this filter list.
<!-- TODO: Give an example of this, i.e. some input and ALSO the resulting output -->
</Subsection>

<Subsection Label="@ChapterInfo">
<Index Key="@ChapterInfo"><C>@ChapterInfo</C></Index>
<Heading>@ChapterInfo <A>chapter, section</A></Heading>
Adds the entry to the given chapter and section. Here,
<A>chapter</A> and <A>section</A> are the respective
titles.
</Subsection>


As an example, a full &AutoDoc; comment for with all options could look like this:

<Listing><![CDATA[
#! @Description
#! Computes the list of lists of degrees of ordinary characters
#! associated to the <A>p</A>-blocks of the group <A>G</A>
#! with <A>p</A>-modular character table <A>modtbl</A>
#! and underlying ordinary character table <A>ordtbl</A>.
#! @Returns a list
#! @Arguments modtbl
#! @Group CharacterDegreesOfBlocks
#! @FunctionLabel chardegblocks
#! @ChapterInfo Blocks, Attributes
DeclareAttribute( "CharacterDegreesOfBlocks",
        IsBrauerTable );
]]></Listing>

</Section>

<Section>
<Heading>Other documentation comments</Heading>

There are also some commands which can be used in &AutoDoc; comments
that are not associated to any declaration.

<Subsection Label="@Chapter">
<Index Key="@Chapter"><C>@Chapter</C></Index>
<Heading>@Chapter <A>name</A></Heading>
Sets a chapter, all functions without seperate info will be added to this chapter.
Also all text comments, i.e. lines that begin with #! without a command, and which do not
follow after @description, will be added to the chapter as regular text.

Example:

<Listing><![CDATA[
#! @Chapter My chapter
#!  This is my chapter.
#!  I document my stuff in it.
]]></Listing>
</Subsection>

<Subsection Label="@Section">
<Index Key="@Section"><C>@Section</C></Index>
<Heading>@Section <A>name</A></Heading>
Sets a section like chapter sets a chapter.

<Listing><![CDATA[
#! @Section My first manual section
#!  In this section I am going to document my first method.
]]></Listing>
</Subsection>

<Subsection Label="@EndSection">
<Index Key="@EndSection"><C>@EndSection</C></Index>
<Heading>@EndSection</Heading>
Closes the current section.

<Listing><![CDATA[
#! @EndSection
#### The following text again belongs to the chapter
#! Now we have a second section.
]]></Listing>
</Subsection>

<Subsection Label="@AutoDoc">
<Index Key="@AutoDoc"><C>@AutoDoc</C></Index>
<Heading>@AutoDoc</Heading>

Causes all subsequent declarations to be documented in the manual,
regardless of whether they have an &AutoDoc; comment in front of
them or not.
</Subsection>

<Subsection Label="@EndAutoDoc">
<Index Key="@EndAutoDoc"><C>@EndAutoDoc</C></Index>
<Heading>@EndAutoDoc</Heading>
Ends the affect of <C>@AutoDoc</C>. So from here on, again only declarations
with an explicit &AutoDoc; comment in front are added to the manual.

<Listing><![CDATA[
#! @AutoDoc

DeclareOperation( "Operation1", [ IsList ] );

DeclareProperty( "IsProperty", IsList );

#! @EndAutoDoc
]]></Listing>
</Subsection>

<Subsection Label="@BeginGroup">
<Index Key="@BeginGroup"><C>@BeginGroup</C></Index>
<Heading>@BeginGroup <A>[grpname]</A></Heading>
Starts a group. All following documented declarations without an
explicit <C>@Group</C> command are grouped together in the same group
with the given name. If no name is given, then a new nameless group is
generated.
The effect of this command is ended when an <C>@EndGroup</C> command
is reached.
<P/>

See section <Ref Sect="Groups"/> for more information about groups.
</Subsection>

<Subsection Label="@EndGroup">
<Index Key="@EndGroup"><C>@EndGroup</C></Index>
<Heading>@EndGroup</Heading>
Ends the current group.

<Listing><![CDATA[
#! @BeginGroup MyGroup
#!
DeclareAttribute( "GroupedAttribute",
                  IsList );

DeclareOperation( "NonGroupedOperation",
                  [ IsObject ] );

#!
DeclareOperation( "GroupedOperation",
                  [ IsList, IsRubbish ] );
#! @EndGroup
]]></Listing>
</Subsection>

<Subsection Label="@Level">
<Index Key="@Level"><C>@Level</C></Index>
<Heading>@Level <A>lvl</A></Heading>
Sets the current level of the documentation. All items created after this,
chapters, sections, and items, are given the level <A>lvl</A>,
until the <C>@ResetLevel</C> command resets the level to 0 or another level
is set.
<P/>

See section <Ref Sect="Level"/> for more information about groups.
</Subsection>

<Subsection Label="@ResetLevel">
<Index Key="@ResetLevel"><C>@ResetLevel</C></Index>
<Heading>@ResetLevel</Heading>
Resets the current level to 0.
<P/>
</Subsection>


<Subsection Label="@Example">
<Index Key="@Example"><C>@Example and @EndExample</C></Index>
<Heading>@Example and @EndExample</Heading>
@Example inserts an example into the manual. The syntax is like the example enviroment
in GAPDoc. This examples can be tested by GAPDoc, and also stay readable by GAP.
The GAP prompt is added by AutoDoc.
@EndExample ends the example block.
<Listing><![CDATA[
#! @Example
S3 := SymmetricGroup(5);
#! Sym( [ 1 .. 5 ] )
Order(S3);
#! 120
#! @EndExample
]]></Listing>
</Subsection>

<Subsection Label="@System">
<Index Key="@System"><C>@System and @InsertSystem</C></Index>
<Heading>@System <A>name</A> and @InsertSystem <A>name</A></Heading>
@System makes the next documentation item (can be an example, a text or a function)
not to be inserted in the documentation at it's point in the file, but at the point
where the @InsertSystem <A>name</A> command is. This can be used to insert examples from
different files at a specific point in the documentation.
<Listing><![CDATA[
#! @System Example_Symmetric_Group
#! @Example
S3 := SymmetricGroup(5);
#! Sym( [ 1 .. 5 ] )
Order(S3);
#! 120
#! @EndExample
]]></Listing>

<Listing><![CDATA[
#! @SInsertystem Example_Symmetric_Group
]]></Listing>
</Subsection>

</Section>
<Section Label="Groups">
<Heading>Grouping</Heading>

TODO: explain more about groups and what they do, how they look in the
generated output etc.
<P/>

Note that group names are globally unique throughout the whole manual.
That is, groups with the same name are in fact merged into a single group, even if they
were declared in different source files.
Thus you can have multiple <C>@BeginGroup</C> / <C>@EndGroup</C> pairs using the
same group name, in different places, and these all will refer to the same group.
<P/>

Moreover, this means that you can add items to a group via the <C>@Group</C> command
in the &AutoDoc; comment of an arbitrary declaration, at any time.


</Section>

<Section Label="Level">
<Heading>Level</Heading>
  Levels can be set to not write certain parts in the manual by default.
  Every entry has by default the level 0. The command <C>@Level</C> can
  be used to set the level of the following part to a higher level, for
  example 1, and prevent it from being printed to the manual by default.
  However, if one sets the level to a higher value in the autodoc option of
  <C>AutoDoc</C>, the parts will be included in the manual at the specific place.

<Listing><![CDATA[
#! This text will be printed to the manual.
#! @Level 1
#! This text will be printed to the manual if created with level 1 or higher.
#! @Level 2
#! This text will be printed to the manual if created with level 2 or higher.
#! @ResetLevel
#! This text will be printed to the manual.
]]></Listing>
</Section>

</Chapter>
